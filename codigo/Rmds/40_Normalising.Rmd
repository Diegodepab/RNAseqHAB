## Factores de normalización 

La función `calcNormFactors()` supone que la mayoría de los genes no cambia y compara las cuentas totales de los que más cambian entre las muestras para calcular el **factor de escalado** que disminuye al mínimo las diferencias de `logFC` entre ellas. 
Cuanto más cercano a 1 esté el factor, menos transformación se necesita. 

Vamos a normalizar los datos con el filtro riguroso, que hemos visto que es el más apropiado

```{r NormFacts}
x.filt.norm <- calcNormFactors(x.filt, method = "TMM")
cat("Resulting normalization factors:\n", x.filt.norm$samples$norm.factors, "\n")
```

Representemos ahora estos valores para apreciar mejor si están muy dispersos o no. Lo ideal es que en la primera no haya valores extremos (_outliers_) fuera de los cuartiles (en caso de haber alguno, podría plantearse su eliminación del análisis):

```{r NormFactPlot, fig.width=5, fig.height=5, out.width=c('50%', '50%'), fig.show='hold'}
boxplot(x.filt.norm$samples$norm.factors, 
        xlab = "All samples together", 
        ylab = "Values of NormFactors", 
        main = "Are there outliers in NormFactors?")
        
boxplot(x.filt.norm$samples$norm.factors~rownames(x.filt.norm$samples), 
        xlab = "",	
        ylab = "Values of NormFactors", 
        main = "Madians of NormFactors", 
        las = 2)
# línea en 1 para tener una referencia clara
abline(h = 1.0, lty = 3)
```



## Normalizados frente a originales  {.tabset}

Definamos unas constantes que nos van a facilitar la vida posterior:

```{r textConstt}
RAW_TXT <- "Raw data"
FILT_TXT <- "Filtered data"
NORM_TXT <- "Norm+filt data"
```



### ¿Más uniformes? {-}

Comparemos la distribución de los valores de cada muestra tras filtrado y normalización.
Lo esperable es que sean más homogéneos y uniformes (luego comparables) que los originales.

```{r ComparaNorm, fig.width=4, fig.height=5, out.width=c('33%', '33%', '33%'), fig.show='hold'}
# vamos a usar las logCPM para inspeccionarlo
x.filt.norm.lcpm <- cpm(x.filt.norm, log = TRUE)

boxplot(x.lcpm, 
        las = 2, 
        col = EXP_COLORS, 
        main = RAW_TXT, 
        ylab = "Log-cpm")
boxplot(x.filt.lcpm, 
        las = 2, 
        col = EXP_COLORS, 
        main = FILT_TXT, 
        ylab = "Log-cpm")
boxplot(x.filt.norm.lcpm, 
        las = 2, 
        col = EXP_COLORS, 
        main = NORM_TXT, 
        ylab = "Log-cpm")
```

Se ve que, en `r NORM_TXT`, las medianas están alineadas y los intervalos de los cuartiles son casi idénticos en todas las muestras.

> **IMPORTANT:** Any sample with outlier scaling factor and quartile distribution should be removed to improve the analysis.



### ¿Se agrupan mejor? {-}

Vamos a volver a hacer la representación de los [MDS] para ver si el agrupamiento se mantiene, se mejora o empeora. En caso de empeorar, tenemos un problema. La comparamos con un análisis de componentes principales ([PCA]).

```{r MDStrasNorm, fig.width=8, fig.height=5, }
par(mfrow = c(1, 2))
plotMDS(x.filt.norm, 
        labels = x.filt.norm$samples$group, 
        col = EXP_COLORS,
        main = "Sample similarities by MDS")

# PCA using log-CPM instead of CPM
PlotMyPCA(x.filt.norm.lcpm, "Sample similarities by PCA")
```

> **IMPORTANT:** If component contribution of both axis are greater than [before][Visualización del filtrado], normalisation is expected to improve data quality.




## Save normalised data

```{r datatableNorm}
# traditional method to save normalised CPMs
normCPMs <- cpm(x.filt.norm)
fileName <- SaveTSV(normCPMs, "normalisedCPM-")
message("TMM-normalised **CPMs** were saved in\n", fileName)

# to save normalised counts, from https://support.bioconductor.org/p/133671/
norm_counts <- estimateCommonDisp(x.filt.norm, verbose=FALSE)
norm_counts <- estimateTagwiseDisp(norm_counts, trend="none")
norm_count_matrix <- t(t(norm_counts$pseudo.counts)*(norm_counts$samples$norm.factors))
fileName <- SaveTSV(norm_count_matrix, "normalisedCounts-")
message("TMM-normalised **counts** were saved in\n", fileName)

rm(normCPMs, norm_counts, norm_count_matrix)
```

